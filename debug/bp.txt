import React, { Suspense, useEffect, useLayoutEffect } from 'react';
import { useParams } from 'react-router-dom';
import { sortedBlogPosts } from '../blogData';
import Seo from '../components/Seo';
import ModernTOC from '../components/ModernTOC';
import NotFoundPage from './NotFoundPage';
import sanitizeArticleStart from '../lib/sanitizeArticleStart';

// --- Ultra-reliable TOC/Hero shim (CWV-safe) ---
function ensureHeroAndTOCOrderAndMeta(postImageSrc) {
  try {
    const article =
      document.querySelector('article.single, article.post, article') ||
      document.querySelector('.single-post, .post');
    if (!article) return;

    const header = article.querySelector('.post-header, header');
    const heroFig =
      article.querySelector('figure.post-hero') ||
      (header &&
        header.nextElementSibling &&
        header.nextElementSibling.id === 'hero-slot' &&
        header.nextElementSibling.firstElementChild) ||
      null;
    if (!heroFig) return;

    // 1) Ensure #toc-anchor exists and sits immediately after hero (never in a figure)
    let anchor = document.querySelector('#toc-anchor');
    if (!anchor) {
      anchor = document.createElement('div');
      anchor.id = 'toc-anchor';
    }
    heroFig.insertAdjacentElement('afterend', anchor);
    if (anchor.closest('figure')) anchor.closest('figure').insertAdjacentElement('afterend', anchor);

    // Normal flow (no overlay)
    Object.assign(heroFig.style, { display: 'block', clear: 'both', position: 'relative', zIndex: 0, marginBottom: '0.5rem' });
    Object.assign(anchor.style, { display: 'block', clear: 'both', position: 'relative', zIndex: 1, minHeight: '1px', margin: '0.25rem 0' });

    // 2) If the hero has no figcaption, adopt the adjacent caption/meta of the first duplicate image
    const heroImg = heroFig.querySelector('img');
    const heroSrc = (heroImg && (heroImg.getAttribute('src') || heroImg.src)) || postImageSrc || '';
    let adoptedCaption = !!heroFig.querySelector('figcaption');
    let removedOneDuplicate = false;

    const imgs = Array.from(article.querySelectorAll('img')).slice(0, 12);
    for (const img of imgs) {
      const s = (img.getAttribute('src') || img.src || '').toString();
      if (!s || s !== heroSrc) continue;
      if (heroFig.contains(img)) continue; // skip the real hero

      const container = img.closest('figure') || img.parentElement;

      if (!adoptedCaption && container) {
        const next = container.nextElementSibling;
        const isFigcap = next && (next.tagName || '').toLowerCase() === 'figcaption';
        const looksMeta = next && /(\bimage-meta\b|\bfigure-meta\b|caption|meta)/i.test(next.className || '');
        if (isFigcap || looksMeta) {
          const cap = document.createElement('figcaption');
          cap.className = 'image-caption';
          cap.innerHTML = next.innerHTML || next.textContent || '';
          heroFig.appendChild(cap);
          next.remove();
          adoptedCaption = true;
        }
      }

      // Remove only ONE duplicate; leave later images and their meta alone
      if (!removedOneDuplicate) {
        if (container && container.parentElement) container.remove(); else img.remove();
        removedOneDuplicate = true;
      }
    }

    // 3) If a legacy TOC exists elsewhere, move it into the anchor to enforce order visually
    const legacyToc = article.querySelector('[data-toc-mount], .toc-shell, #toc');
    if (legacyToc && legacyToc !== anchor) {
      anchor.innerHTML = '';
      anchor.appendChild(legacyToc);
    }
  } catch {}
}

// NOTE: no RegEx helpers required; hero is rendered or promoted via effects below.

const BlogPostPage = () => {
  const { slug } = useParams();
  const post = sortedBlogPosts.find((p) => p.slug === slug);
  const heroImageSrc = post?.image || '';

  // Sanitize odd leading characters at article start without blocking paint
  useEffect(() => {
    if (typeof window !== 'undefined') {
      if ('requestIdleCallback' in window) {
        // @ts-ignore requestIdleCallback type
        const id = window.requestIdleCallback(() => sanitizeArticleStart('article'), { timeout: 1200 });
        return () => window.cancelIdleCallback && window.cancelIdleCallback(id);
      } else {
        const t = setTimeout(() => sanitizeArticleStart('article'), 0);
        return () => clearTimeout(t);
      }
    }
  }, []);

  // Preload the hero image source to double-lock instant LCP on first navigation
  useEffect(() => {
    if (!heroImageSrc) return;
    try {
      let link = document.querySelector('link[data-hero-preload]');
      if (!link) {
        link = document.createElement('link');
        link.setAttribute('data-hero-preload', '1');
        link.rel = 'preload';
        link.as = 'image';
        link.href = heroImageSrc;
        document.head.appendChild(link);
      }
    } catch {}
  }, [heroImageSrc]);

  // Outline implementation: adopt caption from duplicates and remove their containers; ensure TOC anchor follows hero
  useLayoutEffect(() => {
    try {
      const article =
        document.querySelector('article.single, article.post, article') ||
        document.querySelector('.single-post, .post');
      if (!article) return;

      const heroFig = article.querySelector('figure.post-hero');
      const heroImg = heroFig?.querySelector('img');
      if (!heroFig || !heroImg) return;

      const heroSrc = (heroImg.src || '').split('?')[0].split('#')[0];

      // Find all duplicate hero containers (figures/captions) excluding the real hero
      const containers = Array.from(article.querySelectorAll('figure, .wp-block-image, .wp-caption'))
        .filter((el) => el !== heroFig && el.querySelector('img')?.src?.includes(heroSrc));

      let adoptedCaption = heroFig.querySelector('figcaption');
      for (const el of containers) {
        const capEl = el.querySelector('figcaption, .wp-caption-text');
        if (!adoptedCaption && capEl) {
          const figCap = document.createElement('figcaption');
          figCap.className = 'image-caption';
          figCap.textContent = (capEl.textContent || '').trim();
          heroFig.appendChild(figCap);
          adoptedCaption = figCap;
        }
        el.remove();
      }

      // Ensure TOC anchor is after hero
      const toc = document.getElementById('toc-anchor');
      if (toc && heroFig.nextElementSibling !== toc) {
        heroFig.insertAdjacentElement('afterend', toc);
      }
    } catch {}
  }, [heroImageSrc]);

  // Create the title-after slot after .post-header and a TOC anchor right after it (CWV-safe)
  useLayoutEffect(() => {
    try {
      const article =
        document.querySelector('article.single, article.post, article') ||
        document.querySelector('.single-post, .post');
      if (!article) return;
      const header = article.querySelector('.post-header, header');
      if (!header) return;

      let slot = header.nextElementSibling && (header.nextElementSibling).id === 'title-after-slot'
        ? header.nextElementSibling
        : null;
      if (!slot) {
        slot = document.createElement('div');
        slot.id = 'title-after-slot';
        slot.style.aspectRatio = '1200 / 630';
        slot.style.minHeight = '1px';
        slot.style.display = 'block';
        slot.style.margin = '0.5rem 0 0.25rem';
        header.parentNode && header.parentNode.insertBefore(slot, header.nextSibling);
      }

      let anchor = slot.nextElementSibling && (slot.nextElementSibling).id === 'toc-anchor'
        ? slot.nextElementSibling
        : null;
      if (!anchor) {
        anchor = document.createElement('div');
        anchor.id = 'toc-anchor';
        anchor.style.display = 'block';
        anchor.style.clear = 'both';
        anchor.style.position = 'relative';
        anchor.style.zIndex = '1';
        anchor.style.minHeight = '1px';
        anchor.style.margin = '0.25rem 0';
        slot.insertAdjacentElement('afterend', anchor);
      }
    } catch {}
  }, []);

  // Static anchors are rendered in JSX; no dynamic creation needed.

  // Render-time hero (when post.image exists) — portal it before Suspense so it appears on first paint.
  const fallbackCaption =
    "Confident woman learning how to stop attracting narcissists by walking away from toxic relationships toward healthy boundaries and self-empowerment";

  const Hero = post?.image ? (
    <figure className="lead-figure post-hero">
      <img
        src={post.image}
        alt={post.title || ''}
        width={1200}
        height={630}
        loading="eager"
        decoding="async"
        fetchpriority="high"
        className="w-full h-auto object-cover rounded-lg"
      />
      <figcaption className="image-caption">{post.imageCaption || fallbackCaption}</figcaption>
    </figure>
  ) : null;

  // Minimal portal util
  const PortalInto = ({ selector, children }) => {
    const [target, setTarget] = useState(null);
    useLayoutEffect(() => {
      setTarget(document.querySelector(selector));
    }, [selector]);
    return target ? ReactDOM.createPortal(children, target) : null;
  };

  // Make sure the TOC anchor sits after the rendered hero figure (never overlay it)
  useLayoutEffect(() => {
    try {
      const article =
        document.querySelector('article.single, article.post, article') ||
        document.querySelector('.single-post, .post');
      if (!article) return;

      const slot = document.getElementById('title-after-slot');
      const anchor = document.getElementById('toc-anchor');
      const heroFig = article.querySelector('figure.post-hero');
      if (!slot || !anchor || !heroFig) return;

      if (anchor.previousElementSibling !== heroFig) {
        heroFig.insertAdjacentElement('afterend', anchor);
      }
      if (anchor.closest('figure')) {
        anchor.closest('figure').insertAdjacentElement('afterend', anchor);
      }

      // Clear temporary reservation from the slot now that the hero has rendered
      slot.style.aspectRatio = '';
      slot.style.minHeight = '';
      // Comfortable spacing so the border can't touch the image
      Object.assign(anchor.style, { display: 'block', clear: 'both', marginTop: '12px' });
      // Mark as ready so TOC can mount now
      anchor.setAttribute('data-toc-ready', '1');
    } catch {}
  }, [heroImageSrc]);

  // If we rendered a cover, adopt nearby caption/meta then remove only the first duplicate of the same src (normalized).
  useLayoutEffect(() => {
    if (!heroImageSrc) return;
    try {
      const article = document.querySelector('article.single, article.post, article') || document.querySelector('.single-post, .post');
      if (!article) return;
      const heroFig = article.querySelector('figure.post-hero');
      const heroImg = heroFig ? heroFig.querySelector('img') : null;
      const normalize = (src) => {
        if (!src) return '';
        const s = src.toString();
        const noHash = s.split('#')[0];
        const noQuery = noHash.split('?')[0];
        return noQuery.split('/').pop().toLowerCase();
      };
      const heroSrcNorm = normalize(heroImg ? (heroImg.getAttribute('src') || heroImg.src) : heroImageSrc);
      let adoptedCaption = !!(heroFig && (() => { const fc = heroFig.querySelector('figcaption'); return fc && fc.textContent.trim().length > 0; })());
      let removedDuplicate = false;
      const imgs = Array.from(article.querySelectorAll('img')).slice(0, 30);
      for (const img of imgs) {
        const imgNorm = normalize(img.getAttribute('src') || img.src);
        const isHeroItself = !!(heroFig && heroFig.contains(img));
        if (!imgNorm || imgNorm !== heroSrcNorm || isHeroItself) continue;
        const candidate =
          img.closest('figure, .wp-block-image, .wp-caption, .image, .figure, .relative.overflow-hidden.rounded-lg.shadow-md.my-8.w-full') ||
          img.parentElement;
        const wrapper =
          (candidate && candidate.closest('.wp-block-image, figure, .wp-caption, .wp-block, .wp-container, .image, .figure, .relative.overflow-hidden.rounded-lg.shadow-md.my-8.w-full')) ||
          candidate || img;

        if (heroFig && !adoptedCaption && wrapper) {
          const innerCap = wrapper.querySelector('figcaption, .wp-caption-text, .image-meta, .figure-meta, .caption, [data-caption]');
          const next = wrapper.nextElementSibling;
          const prev = wrapper.previousElementSibling;
          const isCapEl = (el) => !!el && (((el.tagName || '').toLowerCase() === 'figcaption') || /(\bwp-caption-text\b|\bimage-meta\b|\bfigure-meta\b|\bcaption\b|\bmeta\b)/i.test(el.className || ''));
          const siblingCap = isCapEl(next) ? next : (isCapEl(prev) ? prev : null);
          const sourceCap = innerCap || siblingCap;
          if (sourceCap) {
            const cap = document.createElement('figcaption');
            cap.className = 'image-caption';
            cap.innerHTML = sourceCap.innerHTML || sourceCap.textContent || '';
            heroFig.appendChild(cap);
            if (sourceCap !== innerCap && sourceCap.parentElement) sourceCap.remove();
            adoptedCaption = true;
          }
        }
        if (!removedDuplicate) {
          if (wrapper && wrapper.parentElement) wrapper.remove(); else img.remove();
          removedDuplicate = true;
        }
      }
    } catch {}
  }, [heroImageSrc]);

  // === Fallback: Lead image promotion by moving the first in-body image (when no cover provided) ===
  useLayoutEffect(() => {
    if (post && post.image) return; // skip when we already render a cover
    try {
      if (window.__leadImagePatched || window.__coverInjected) return;

      const article = document.querySelector('article.single, article.post, article') ||
                      document.querySelector('.single-post, .post');
      if (!article) return;
      const contentRoot = article;

      // Static anchors already exist; no dynamic creation required.

      const toc = document.querySelector('#toc-anchor') || document.querySelector('[data-toc-mount]');

      // Find the first in-body image
      const candidates = [
        'article .post-content img',
        'article img',
        '.post img',
        '.entry-content img',
      ];
      let firstImg = null;
      for (const sel of candidates) {
        const candidate = document.querySelector(sel);
        if (candidate && (candidate.getAttribute('src') || candidate.src)) { firstImg = candidate; break; }
      }

      if (firstImg && contentRoot) {
        // Wrap or use existing figure
        let block = firstImg.closest('figure');
        const originalParent = firstImg.parentElement;
        const originalContainer = block || originalParent;
        const createdNow = !block;
        if (!block) {
          block = document.createElement('figure');
          originalParent && originalParent.insertBefore(block, firstImg);
          block.appendChild(firstImg);
        }

        // Mark classes and ensure img attributes
        block.classList.add('lead-figure', 'post-hero');
        const img = block.querySelector('img');
        if (img) {
          const w = img.getAttribute('width') || img.naturalWidth;
          const h = img.getAttribute('height') || img.naturalHeight;
          if (w && !img.getAttribute('width')) img.setAttribute('width', String(w));
          if (h && !img.getAttribute('height')) img.setAttribute('height', String(h));
          img.setAttribute('loading', 'eager');
          img.setAttribute('decoding', 'async');
          img.style.objectFit = 'cover';
          if (!img.style.aspectRatio && w && h) { img.style.aspectRatio = `${w}/${h}`; }
        }

        // Move adjacent caption/meta when we created a new figure
        if (createdNow) {
          const candidate = block.nextElementSibling;
          if (candidate) {
            const t = (candidate.tagName || '').toLowerCase();
            const cls = candidate.className || '';
            if (t === 'figcaption') {
              block.appendChild(candidate);
            } else if (t === 'p' || /(\bimage-meta\b|\bfigure-meta\b)/.test(cls) || /caption|meta/i.test(cls)) {
              const cap = document.createElement('figcaption');
              cap.className = 'image-caption';
              cap.innerHTML = candidate.innerHTML || candidate.textContent || '';
              block.appendChild(cap);
              candidate.remove();
            }
          }
        }

        // Normalize/ensure caption class
        const fc = block.querySelector('figcaption');
        if (fc && !fc.classList.contains('image-caption')) fc.classList.add('image-caption');

        // Insert into hero slot when available, else before ToC / after header
        const header2 = (article && article.querySelector('.post-header')) || document.querySelector('.post-header') || document.querySelector('header');
        const heroSlot2 = header2 && header2.nextElementSibling && header2.nextElementSibling.id === 'hero-slot' ? header2.nextElementSibling : null;
        if (heroSlot2) {
          heroSlot2.innerHTML = '';
          heroSlot2.appendChild(block);
          heroSlot2.style.minHeight = '0px';
        } else {
          const anchor = (document.querySelector('#toc-anchor')) || (toc && toc.parentNode ? toc : (header2 && header2.nextSibling ? header2.nextSibling : header2));
          if (anchor && anchor.parentNode) {
            anchor.parentNode.insertBefore(block, anchor);
          } else if (header2 && header2.parentNode) {
            header2.parentNode.insertBefore(block, header2.nextSibling);
          }
        }

        // Cleanup: remove leftover empty containers/placeholders in body
        const isTrulyEmpty = (el) => el && el.children.length === 0 && ((el.textContent || '').trim() === '');
        if (originalContainer && originalContainer !== block && isTrulyEmpty(originalContainer)) {
          originalContainer.remove();
        }
        // Remove adjacent meta/figcaption next to the old container if present
        if (originalContainer && originalContainer !== block) {
          const next = originalContainer.nextElementSibling;
          if (next) {
            const t = (next.tagName || '').toLowerCase();
            const cls = next.className || '';
            if (t === 'figcaption' || /(\bimage-meta\b|\bfigure-meta\b)/.test(cls) || (t === 'p' && /metadescription/i.test(cls))) {
              next.remove();
            }
          }
        }
        // Remove orphan figures without images
        contentRoot.querySelectorAll('figure').forEach(fig => { if (!fig.querySelector('img')) fig.remove(); });
        // Remove duplicates of SAME src near the top
        if (img && (img.getAttribute('src') || img.src)) {
          const targetSrc = img.getAttribute('src') || img.src;
          contentRoot.querySelectorAll('img').forEach(d => {
            const s = d.getAttribute('src') || d.src;
            if (s === targetSrc && !block.contains(d)) {
              const p = d.closest('figure') || d.parentElement;
              if (p && p.parentElement) p.remove(); else d.remove();
            }
          });
        }
      }

      window.__leadImagePatched = true;
    } catch (e) {
      console.warn('lead-image move non-fatal:', e);
    }
  }, [post]);

  if (!post) {
    return <NotFoundPage />;
  }

  const PostComponent = post.component;
  const seoTitleMap = {
    'how-to-know-if-you-deserve-better-relationship-introvert-woman-guide': 'Do You Deserve Better? 7 Clear Signs for Introvert Women',
    'how-to-stop-attracting-narcissists-9-proven-strategies': 'How to Stop Attracting Narcissists: 9 Proven Strategies',
    'how-to-be-confident-as-an-introvert-woman-guide': 'How to Be Confident as an Introvert Woman',
    'how-to-speak-up-in-meetings-introvert-strategies-2025': 'How to Speak Up in Meetings as an Introvert',
    'introvert-social-battery-drained-recovery-methods': 'Introvert Social Battery Drained? 9 Ways to Recharge',
    'morning-routine-for-confidence-and-productivity-2025': 'Morning Routine for Confidence and Productivity',
    'post-breakup-glow-up-transformation-guide-10-proven-steps-to-become-your-best-self-in-2025': 'Post-Breakup Glow Up: 10 Steps',
  };
  const seoTitle = seoTitleMap[post.slug] || post.title;

  return (
    <>
      <Seo
        title={seoTitle}
        description={post.description}
        type="article"
        article={{
          title: post.title,
          authorName: 'Marica Šinko',
          datePublished: `${post.date}T00:00:00+00:00`,
          image: post.image,
        }}
      />
      <section id=\"intro-media\" className=\"intro-media\">
        "+'{'+"Hero"+'}'+"
        <aside id=\"toc\" className=\"qs-toc-container\">
          <ModernTOC rootSelector=\".post-body\" />
        </aside>
      </section>

      <Suspense
        fallback={
          <div className=\"flex justify-center items-center py-24\">\n            <div className=\"text-brand-primary animate-pulse\">Loading article...</div>\n          </div>
        }
      >
        <div className=\"post-body\">\n          "+'{'+"PostComponent"+'}'+"\n        </div>
      </Suspense>
    </>
  );
};

export default BlogPostPage;



